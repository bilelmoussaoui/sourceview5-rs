// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceBackgroundPatternType")]
pub enum BackgroundPatternType {
    #[doc(alias = "GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID")]
    Grid,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BackgroundPatternType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BackgroundPatternType::{}",
            match *self {
                BackgroundPatternType::None => "None",
                BackgroundPatternType::Grid => "Grid",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BackgroundPatternType {
    type GlibType = ffi::GtkSourceBackgroundPatternType;

    fn to_glib(&self) -> ffi::GtkSourceBackgroundPatternType {
        match *self {
            BackgroundPatternType::None => ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE,
            BackgroundPatternType::Grid => ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID,
            BackgroundPatternType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceBackgroundPatternType> for BackgroundPatternType {
    unsafe fn from_glib(value: ffi::GtkSourceBackgroundPatternType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BackgroundPatternType::None,
            1 => BackgroundPatternType::Grid,
            value => BackgroundPatternType::__Unknown(value),
        }
    }
}

impl StaticType for BackgroundPatternType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_background_pattern_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BackgroundPatternType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BackgroundPatternType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BackgroundPatternType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceBracketMatchType")]
pub enum BracketMatchType {
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE")]
    OutOfRange,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_FOUND")]
    Found,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BracketMatchType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BracketMatchType::{}",
            match *self {
                BracketMatchType::None => "None",
                BracketMatchType::OutOfRange => "OutOfRange",
                BracketMatchType::NotFound => "NotFound",
                BracketMatchType::Found => "Found",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BracketMatchType {
    type GlibType = ffi::GtkSourceBracketMatchType;

    fn to_glib(&self) -> ffi::GtkSourceBracketMatchType {
        match *self {
            BracketMatchType::None => ffi::GTK_SOURCE_BRACKET_MATCH_NONE,
            BracketMatchType::OutOfRange => ffi::GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE,
            BracketMatchType::NotFound => ffi::GTK_SOURCE_BRACKET_MATCH_NOT_FOUND,
            BracketMatchType::Found => ffi::GTK_SOURCE_BRACKET_MATCH_FOUND,
            BracketMatchType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceBracketMatchType> for BracketMatchType {
    unsafe fn from_glib(value: ffi::GtkSourceBracketMatchType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BracketMatchType::None,
            1 => BracketMatchType::OutOfRange,
            2 => BracketMatchType::NotFound,
            3 => BracketMatchType::Found,
            value => BracketMatchType::__Unknown(value),
        }
    }
}

impl StaticType for BracketMatchType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_bracket_match_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BracketMatchType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BracketMatchType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BracketMatchType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceChangeCaseType")]
pub enum ChangeCaseType {
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_LOWER")]
    Lower,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_UPPER")]
    Upper,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_TOGGLE")]
    Toggle,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_TITLE")]
    Title,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ChangeCaseType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ChangeCaseType::{}",
            match *self {
                ChangeCaseType::Lower => "Lower",
                ChangeCaseType::Upper => "Upper",
                ChangeCaseType::Toggle => "Toggle",
                ChangeCaseType::Title => "Title",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ChangeCaseType {
    type GlibType = ffi::GtkSourceChangeCaseType;

    fn to_glib(&self) -> ffi::GtkSourceChangeCaseType {
        match *self {
            ChangeCaseType::Lower => ffi::GTK_SOURCE_CHANGE_CASE_LOWER,
            ChangeCaseType::Upper => ffi::GTK_SOURCE_CHANGE_CASE_UPPER,
            ChangeCaseType::Toggle => ffi::GTK_SOURCE_CHANGE_CASE_TOGGLE,
            ChangeCaseType::Title => ffi::GTK_SOURCE_CHANGE_CASE_TITLE,
            ChangeCaseType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceChangeCaseType> for ChangeCaseType {
    unsafe fn from_glib(value: ffi::GtkSourceChangeCaseType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ChangeCaseType::Lower,
            1 => ChangeCaseType::Upper,
            2 => ChangeCaseType::Toggle,
            3 => ChangeCaseType::Title,
            value => ChangeCaseType::__Unknown(value),
        }
    }
}

impl StaticType for ChangeCaseType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_change_case_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ChangeCaseType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ChangeCaseType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ChangeCaseType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompletionActivation")]
pub enum CompletionActivation {
    #[doc(alias = "GTK_SOURCE_COMPLETION_ACTIVATION_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_COMPLETION_ACTIVATION_INTERACTIVE")]
    Interactive,
    #[doc(alias = "GTK_SOURCE_COMPLETION_ACTIVATION_USER_REQUESTED")]
    UserRequested,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CompletionActivation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CompletionActivation::{}",
            match *self {
                CompletionActivation::None => "None",
                CompletionActivation::Interactive => "Interactive",
                CompletionActivation::UserRequested => "UserRequested",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CompletionActivation {
    type GlibType = ffi::GtkSourceCompletionActivation;

    fn to_glib(&self) -> ffi::GtkSourceCompletionActivation {
        match *self {
            CompletionActivation::None => ffi::GTK_SOURCE_COMPLETION_ACTIVATION_NONE,
            CompletionActivation::Interactive => ffi::GTK_SOURCE_COMPLETION_ACTIVATION_INTERACTIVE,
            CompletionActivation::UserRequested => {
                ffi::GTK_SOURCE_COMPLETION_ACTIVATION_USER_REQUESTED
            }
            CompletionActivation::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompletionActivation> for CompletionActivation {
    unsafe fn from_glib(value: ffi::GtkSourceCompletionActivation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CompletionActivation::None,
            1 => CompletionActivation::Interactive,
            2 => CompletionActivation::UserRequested,
            value => CompletionActivation::__Unknown(value),
        }
    }
}

impl StaticType for CompletionActivation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_completion_activation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CompletionActivation {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CompletionActivation {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CompletionActivation {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompletionColumn")]
pub enum CompletionColumn {
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_ICON")]
    Icon,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_BEFORE")]
    Before,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_TYPED_TEXT")]
    TypedText,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_AFTER")]
    After,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_COMMENT")]
    Comment,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_DETAILS")]
    Details,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CompletionColumn {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CompletionColumn::{}",
            match *self {
                CompletionColumn::Icon => "Icon",
                CompletionColumn::Before => "Before",
                CompletionColumn::TypedText => "TypedText",
                CompletionColumn::After => "After",
                CompletionColumn::Comment => "Comment",
                CompletionColumn::Details => "Details",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CompletionColumn {
    type GlibType = ffi::GtkSourceCompletionColumn;

    fn to_glib(&self) -> ffi::GtkSourceCompletionColumn {
        match *self {
            CompletionColumn::Icon => ffi::GTK_SOURCE_COMPLETION_COLUMN_ICON,
            CompletionColumn::Before => ffi::GTK_SOURCE_COMPLETION_COLUMN_BEFORE,
            CompletionColumn::TypedText => ffi::GTK_SOURCE_COMPLETION_COLUMN_TYPED_TEXT,
            CompletionColumn::After => ffi::GTK_SOURCE_COMPLETION_COLUMN_AFTER,
            CompletionColumn::Comment => ffi::GTK_SOURCE_COMPLETION_COLUMN_COMMENT,
            CompletionColumn::Details => ffi::GTK_SOURCE_COMPLETION_COLUMN_DETAILS,
            CompletionColumn::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompletionColumn> for CompletionColumn {
    unsafe fn from_glib(value: ffi::GtkSourceCompletionColumn) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CompletionColumn::Icon,
            1 => CompletionColumn::Before,
            2 => CompletionColumn::TypedText,
            3 => CompletionColumn::After,
            4 => CompletionColumn::Comment,
            5 => CompletionColumn::Details,
            value => CompletionColumn::__Unknown(value),
        }
    }
}

impl StaticType for CompletionColumn {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_completion_column_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CompletionColumn {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CompletionColumn {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CompletionColumn {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompressionType")]
pub enum CompressionType {
    #[doc(alias = "GTK_SOURCE_COMPRESSION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_COMPRESSION_TYPE_GZIP")]
    Gzip,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CompressionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CompressionType::{}",
            match *self {
                CompressionType::None => "None",
                CompressionType::Gzip => "Gzip",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for CompressionType {
    type GlibType = ffi::GtkSourceCompressionType;

    fn to_glib(&self) -> ffi::GtkSourceCompressionType {
        match *self {
            CompressionType::None => ffi::GTK_SOURCE_COMPRESSION_TYPE_NONE,
            CompressionType::Gzip => ffi::GTK_SOURCE_COMPRESSION_TYPE_GZIP,
            CompressionType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompressionType> for CompressionType {
    unsafe fn from_glib(value: ffi::GtkSourceCompressionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CompressionType::None,
            1 => CompressionType::Gzip,
            value => CompressionType::__Unknown(value),
        }
    }
}

impl StaticType for CompressionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_compression_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CompressionType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CompressionType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CompressionType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceFileLoaderError")]
pub enum FileLoaderError {
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG")]
    TooBig,
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED")]
    EncodingAutoDetectionFailed,
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK")]
    ConversionFallback,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileLoaderError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileLoaderError::{}",
            match *self {
                FileLoaderError::TooBig => "TooBig",
                FileLoaderError::EncodingAutoDetectionFailed => "EncodingAutoDetectionFailed",
                FileLoaderError::ConversionFallback => "ConversionFallback",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileLoaderError {
    type GlibType = ffi::GtkSourceFileLoaderError;

    fn to_glib(&self) -> ffi::GtkSourceFileLoaderError {
        match *self {
            FileLoaderError::TooBig => ffi::GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG,
            FileLoaderError::EncodingAutoDetectionFailed => {
                ffi::GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED
            }
            FileLoaderError::ConversionFallback => {
                ffi::GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK
            }
            FileLoaderError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceFileLoaderError> for FileLoaderError {
    unsafe fn from_glib(value: ffi::GtkSourceFileLoaderError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileLoaderError::TooBig,
            1 => FileLoaderError::EncodingAutoDetectionFailed,
            2 => FileLoaderError::ConversionFallback,
            value => FileLoaderError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileLoaderError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_file_loader_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FileLoaderError::TooBig),
            1 => Some(FileLoaderError::EncodingAutoDetectionFailed),
            2 => Some(FileLoaderError::ConversionFallback),
            value => Some(FileLoaderError::__Unknown(value)),
        }
    }
}

impl StaticType for FileLoaderError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_file_loader_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileLoaderError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileLoaderError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileLoaderError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceFileSaverError")]
pub enum FileSaverError {
    #[doc(alias = "GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS")]
    InvalidChars,
    #[doc(alias = "GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED")]
    ExternallyModified,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FileSaverError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FileSaverError::{}",
            match *self {
                FileSaverError::InvalidChars => "InvalidChars",
                FileSaverError::ExternallyModified => "ExternallyModified",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FileSaverError {
    type GlibType = ffi::GtkSourceFileSaverError;

    fn to_glib(&self) -> ffi::GtkSourceFileSaverError {
        match *self {
            FileSaverError::InvalidChars => ffi::GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS,
            FileSaverError::ExternallyModified => {
                ffi::GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED
            }
            FileSaverError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceFileSaverError> for FileSaverError {
    unsafe fn from_glib(value: ffi::GtkSourceFileSaverError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FileSaverError::InvalidChars,
            1 => FileSaverError::ExternallyModified,
            value => FileSaverError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileSaverError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_file_saver_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FileSaverError::InvalidChars),
            1 => Some(FileSaverError::ExternallyModified),
            value => Some(FileSaverError::__Unknown(value)),
        }
    }
}

impl StaticType for FileSaverError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_file_saver_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileSaverError {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileSaverError {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileSaverError {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceGutterRendererAlignmentMode")]
pub enum GutterRendererAlignmentMode {
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL")]
    Cell,
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST")]
    First,
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST")]
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for GutterRendererAlignmentMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "GutterRendererAlignmentMode::{}",
            match *self {
                GutterRendererAlignmentMode::Cell => "Cell",
                GutterRendererAlignmentMode::First => "First",
                GutterRendererAlignmentMode::Last => "Last",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for GutterRendererAlignmentMode {
    type GlibType = ffi::GtkSourceGutterRendererAlignmentMode;

    fn to_glib(&self) -> ffi::GtkSourceGutterRendererAlignmentMode {
        match *self {
            GutterRendererAlignmentMode::Cell => {
                ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL
            }
            GutterRendererAlignmentMode::First => {
                ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST
            }
            GutterRendererAlignmentMode::Last => {
                ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST
            }
            GutterRendererAlignmentMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceGutterRendererAlignmentMode> for GutterRendererAlignmentMode {
    unsafe fn from_glib(value: ffi::GtkSourceGutterRendererAlignmentMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GutterRendererAlignmentMode::Cell,
            1 => GutterRendererAlignmentMode::First,
            2 => GutterRendererAlignmentMode::Last,
            value => GutterRendererAlignmentMode::__Unknown(value),
        }
    }
}

impl StaticType for GutterRendererAlignmentMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_gutter_renderer_alignment_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GutterRendererAlignmentMode {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GutterRendererAlignmentMode {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GutterRendererAlignmentMode {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceNewlineType")]
pub enum NewlineType {
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_LF")]
    Lf,
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_CR")]
    Cr,
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_CR_LF")]
    CrLf,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NewlineType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NewlineType::{}",
            match *self {
                NewlineType::Lf => "Lf",
                NewlineType::Cr => "Cr",
                NewlineType::CrLf => "CrLf",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for NewlineType {
    type GlibType = ffi::GtkSourceNewlineType;

    fn to_glib(&self) -> ffi::GtkSourceNewlineType {
        match *self {
            NewlineType::Lf => ffi::GTK_SOURCE_NEWLINE_TYPE_LF,
            NewlineType::Cr => ffi::GTK_SOURCE_NEWLINE_TYPE_CR,
            NewlineType::CrLf => ffi::GTK_SOURCE_NEWLINE_TYPE_CR_LF,
            NewlineType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceNewlineType> for NewlineType {
    unsafe fn from_glib(value: ffi::GtkSourceNewlineType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NewlineType::Lf,
            1 => NewlineType::Cr,
            2 => NewlineType::CrLf,
            value => NewlineType::__Unknown(value),
        }
    }
}

impl StaticType for NewlineType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_newline_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NewlineType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NewlineType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NewlineType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceSmartHomeEndType")]
pub enum SmartHomeEndType {
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_DISABLED")]
    Disabled,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_BEFORE")]
    Before,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_AFTER")]
    After,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SmartHomeEndType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SmartHomeEndType::{}",
            match *self {
                SmartHomeEndType::Disabled => "Disabled",
                SmartHomeEndType::Before => "Before",
                SmartHomeEndType::After => "After",
                SmartHomeEndType::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SmartHomeEndType {
    type GlibType = ffi::GtkSourceSmartHomeEndType;

    fn to_glib(&self) -> ffi::GtkSourceSmartHomeEndType {
        match *self {
            SmartHomeEndType::Disabled => ffi::GTK_SOURCE_SMART_HOME_END_DISABLED,
            SmartHomeEndType::Before => ffi::GTK_SOURCE_SMART_HOME_END_BEFORE,
            SmartHomeEndType::After => ffi::GTK_SOURCE_SMART_HOME_END_AFTER,
            SmartHomeEndType::Always => ffi::GTK_SOURCE_SMART_HOME_END_ALWAYS,
            SmartHomeEndType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceSmartHomeEndType> for SmartHomeEndType {
    unsafe fn from_glib(value: ffi::GtkSourceSmartHomeEndType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SmartHomeEndType::Disabled,
            1 => SmartHomeEndType::Before,
            2 => SmartHomeEndType::After,
            3 => SmartHomeEndType::Always,
            value => SmartHomeEndType::__Unknown(value),
        }
    }
}

impl StaticType for SmartHomeEndType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_smart_home_end_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SmartHomeEndType {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SmartHomeEndType {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SmartHomeEndType {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceViewGutterPosition")]
pub enum ViewGutterPosition {
    #[doc(alias = "GTK_SOURCE_VIEW_GUTTER_POSITION_LINES")]
    Lines,
    #[doc(alias = "GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS")]
    Marks,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ViewGutterPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ViewGutterPosition::{}",
            match *self {
                ViewGutterPosition::Lines => "Lines",
                ViewGutterPosition::Marks => "Marks",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ViewGutterPosition {
    type GlibType = ffi::GtkSourceViewGutterPosition;

    fn to_glib(&self) -> ffi::GtkSourceViewGutterPosition {
        match *self {
            ViewGutterPosition::Lines => ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_LINES,
            ViewGutterPosition::Marks => ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS,
            ViewGutterPosition::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceViewGutterPosition> for ViewGutterPosition {
    unsafe fn from_glib(value: ffi::GtkSourceViewGutterPosition) -> Self {
        skip_assert_initialized!();
        match value {
            -30 => ViewGutterPosition::Lines,
            -20 => ViewGutterPosition::Marks,
            value => ViewGutterPosition::__Unknown(value),
        }
    }
}

impl StaticType for ViewGutterPosition {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gtk_source_view_gutter_position_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ViewGutterPosition {
    unsafe fn from_value_optional(value: &glib::Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ViewGutterPosition {
    unsafe fn from_value(value: &glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ViewGutterPosition {
    unsafe fn set_value(value: &mut glib::Value, this: &Self) {
        glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
